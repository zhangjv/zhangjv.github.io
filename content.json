[{"title":"es6-study","date":"2017-06-16T10:02:34.000Z","path":"2017/06/16/es6-study/","text":"总结ES6语法看的高程书作者写的介绍ES6的书,以下是我的总结，应该全是要点 1 块级绑定（let与const） 现有问题：现有的var定义变量方式存在的问题：变量提升，定义的变量都会被提升到函数内部的顶部（或者window全局变量的顶部）；没有块级作用域，如for循环和if条件代码块；没有静态变量；容易覆盖全局变量（window下）； 解决方案：let和const带来了块级作用域、没有变量提升、全局作用域下只会屏蔽已有的全局变量，不会覆盖、禁止重复声明（会报错）、copy循环中的引用（取代闭包）；副作用：暂时性死区（temporal dead zone），在一个代码块中如果typeof先于let或者const定义，会报错 最佳实践：let完全取代var，能用const的地方全部使用const（预期不变的变量值） 2 方法","tags":[{"name":"debug","slug":"debug","permalink":"//zhangjv.github.io/tags/debug/"}]},{"title":"Environment-building","date":"2017-05-31T03:10:40.000Z","path":"2017/05/31/Environment-building/","text":"服务端开发环境搭建 快速搭建lnmp和svn 昨天在家帮同学部署网站，他们找人做了一个php的小网站（ecshop嗯挺老的东西了），帮着选了阿里云主机，然后部署。 懒得逐个配置安装（当然也很害怕出错，毕竟不专业），上网安装脚本找到了这个lnmp.org,就用了。bbs有提到阿里云的内网下载地址，替换下载地址后下载很快，然后加上自动编译安装大概花了半小时左右完成。 下一步就是把项目代码上传到服务器，本来打算ftp上传，又觉得这种方式不利于代码管理和规范，决定在服务器上搭一个svn，然后把本地的代码通过svn提交的服务器上去，使用了大概这个教程,具体哪个记不清楚了，其实很多教程都不是很全面清晰，总之就是yum安装svn之后，创建仓库所在目录，用svn命令生成仓库，然后在仓库目录里面编辑配置文件来分配帐号最后用svn co命令将代码复制到www目录下，改nginx配置文件，将项目目录指定到www下的对应目录，完成。 设置代码提交后自动部署 ,用到的是svn的钩子，svn仓库下有一个hooks目录，里面是各种钩子的模板，用到的是post-commit这个，vim新建一个post-commit文件，内容大概如下： 12345REPOS=\"$1\"REV=\"$2\"export LANG=zh_CN.UTF-8echo \"Code Deployed at `date \"+%Y-%m-%d %H:%M\"`\" &gt;&gt; /home/svn/dl_test/hooks/deploy_log/usr/local/subversion/bin/svn update --username ****** --password ****** /home/www/data/dl_test 保存，然后1chmod +x post-commit 即可 本地navicat连接数据库，导入数据。 最后关于dns解析，网上不少推荐dnspod,在dnspod配置完后需要到注册域名的网站再去配置，dnspod网站有教程说明。 关于防火墙和开端口，按理说应该是iptables里面配置，但是我看服务器的配置文件有点不一样，而在阿里云的控制台上的安全策略可以配置，就在控制台配置了80、443以及svn的3690，出于安全考虑没有直接开放mysql的3306，程序本身localhost可以访问，而开发机可以通过在navicat上ssh连接。 无脑设置项目目录文件权限：cd到项目目录，chmod -R 777 *","tags":[]},{"title":"js的事件机制","date":"2016-09-26T11:02:34.000Z","path":"2016/09/26/event-loop/","text":"js的事件机制 通常说js是单线程执行的，这种说法其实会引起疑惑，至少让我疑惑了，既然是单线程，那么事件机制的主体和观察者角色都怎么来解释？ 实际上，所谓单线程是指执行js程序代码的线程只有一个，可以称作主线程。而其他像ajax的请求、dom事件、定时器事件的观察者实现都是其他的线程来完成的，没有包含的主线程之内。 异步操作完成之后要通知主线程，这样才能知道异步操作完成了。这里就需要一个通知机制来告诉主线程异步完成可以执行回调了，这个通知机制的实现就是任务队列和事件循环。主线程需要做的事就是每次从任务队列取出所有，是所有，要执行的任务，按照顺序执行。取出的任务全部执行完毕后再去任务队列中重新取（事件循环）。如果队列中没有任务，主线程就处于停止状态，等待队列中出现新任务。而其他实现观察者的线程负责向队列中push任务。 关于任务队列，有解释说是消息队列，我认为任务这个词更合适一些。 所以当前执行的代码中加入的异步任务，即使是setTimeout 0，这个回调函数也要等到下个事件循环的时候执行了。 ps：vue的dom更新是异步的，会在下一次事件循环的时候执行（ vm.$nextTick(callback)）","tags":[{"name":"javascript","slug":"javascript","permalink":"//zhangjv.github.io/tags/javascript/"}]},{"title":"debugging-experience","date":"2016-05-26T09:02:34.000Z","path":"2016/05/26/debugging-experience/","text":"总结一下代码调试技巧 持续更新 最近在用java做后台oa的项目，我本身对java不够熟悉，遇到报错尤其是错误信息并不直接的报错，根本看不出原因。在这种凭肉眼看不出错误在哪、报错信息模糊、不能断点调试的情况下，逐段注释和逐行注释来确定错误代码位置就很有效果。123456789101112131415INSERT INTO app ( name, package_name, app_id, desc, update_at, update_by) VALUES ( #&#123;name&#125;, #&#123;packageName&#125;, #&#123;appId&#125;, #&#123;desc&#125;, now(), #&#123;updateBy&#125;) mybatis的sql，通过注释发现是desc这个字段的位置有问题，google得知desc果然是mybatis的关键字，改成description结束。","tags":[{"name":"debug","slug":"debug","permalink":"//zhangjv.github.io/tags/debug/"}]}]